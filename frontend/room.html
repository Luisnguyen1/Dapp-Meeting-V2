<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meeting Room</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/webrtc-adapter/8.1.2/adapter.min.js"></script>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        .video-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            background: #1a1a1a;
            border-radius: 8px;
            overflow: hidden;
        }

        .video-wrapper video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .participant-name {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 4px;
        }

        .video-grid {
            display: grid;
            gap: 10px;
            padding: 10px;
            height: calc(100vh - 100px);
        }

        .video-grid.single-participant {
            grid-template-columns: 1fr;
        }

        .video-grid.two-participants {
            grid-template-columns: 1fr 1fr;
        }

        .video-grid.few-participants {
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
        }

        .video-grid.many-participants {
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
        }
    </style>
</head>
<body>
    <div class="room-container">
        <div class="main-video" id="mainVideo">
            <!-- Spotlight video goes here -->
        </div>
        <div class="thumbnail-grid" id="thumbnailGrid">
            <!-- Small participant videos go here -->
        </div>
        <div id="videoGrid" class="video-grid">
            <!-- Video elements will be added here dynamically -->
        </div>

        <div class="controls-bar">
            <button id="toggleMicBtn" class="control-btn">
                <span class="material-icons">mic</span>
            </button>
            <button id="toggleVideoBtn" class="control-btn">
                <span class="material-icons">videocam</span>
            </button>
            <button id="shareScreenBtn" class="control-btn">
                <span class="material-icons">screen_share</span>
            </button>
            <button id="leaveBtn" class="control-btn leave-btn">
                <span class="material-icons">call_end</span>
            </button>
        </div>
    </div>

    <div class="participant-list">
        <h3>Participants</h3>
        <ul id="participantsList"></ul>
    </div>

    <script>
        const API_BASE = 'http://localhost:8080';
        const APP_ID = "b0ec9f519563a78aacb031048bd9bb2b";
        const APP_TOKEN = "e5aa7484fe2ddf300e69e0e66dd3dd06d8628a5764ac8c237f63f7762d5db234";

        let localStream;
        let localPeerConnection;
        let participants = new Map(); // Store participant connections
        
        const urlParams = new URLSearchParams(window.location.search);
        const roomId = urlParams.get('roomId');
        const username = urlParams.get('username');

        // Get stored device preferences
        const devicePrefs = JSON.parse(localStorage.getItem('selectedDevices') || '{}');

        async function initializeRoom() {
            try {
                // Initialize local media with stored preferences
                localStream = await navigator.mediaDevices.getUserMedia({
                    audio: { deviceId: devicePrefs.audioDeviceId },
                    video: { deviceId: devicePrefs.videoDeviceId }
                });

                // Apply stored enable/disable states
                localStream.getAudioTracks()[0].enabled = devicePrefs.audioEnabled;
                localStream.getVideoTracks()[0].enabled = devicePrefs.videoEnabled;

                // Add local video to grid
                addVideoStream('local', username, localStream);
                updateControls();

                // Get session info from backend
                const response = await fetch(`${API_BASE}/meetings/${roomId}/info`);
                if (!response.ok) {
                    throw new Error('Failed to fetch meeting info');
                }
                
                const meetingInfo = await response.json();
                console.log('Meeting info received:', meetingInfo);

                if (!meetingInfo.sessions || meetingInfo.sessions.length === 0) {
                    throw new Error('No sessions array in meeting info');
                }

                // Find current user's session
                const userSession = meetingInfo.sessions.find(s => s.username === username);
                if (!userSession) {
                    throw new Error('No session found for user: ' + username);
                }

                // Initialize WebRTC with user's session
                await setupCloudflareRTC(userSession.session_id);

                // Start monitoring for participants
                startSessionMonitoring();

            } catch (error) {
                console.error('Error initializing room:', error);
                alert('Failed to initialize meeting room: ' + error.message);
            }
        }

        async function setupCloudflareRTC(sessionId) {
            try {
                localPeerConnection = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.cloudflare.com:3478' }],
                    bundlePolicy: 'max-bundle'
                });
                
                // Lưu session ID vào peer connection để sử dụng sau này
                localPeerConnection.sessionId = sessionId;

                // Add ICE candidate handling
                localPeerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        console.log("New ICE candidate:", event.candidate);
                    }
                };

                // Add connection state handling
                localPeerConnection.onconnectionstatechange = (event) => {
                    console.log("Connection state:", localPeerConnection.connectionState);
                };

                // Add track handling
                localPeerConnection.ontrack = handleRemoteTrack;
                
                const transceivers = localStream.getTracks().map(track =>
                    localPeerConnection.addTransceiver(track, {
                        direction: 'sendonly',
                        streams: [localStream]
                    })
                );

                // Create & set local offer
                const offer = await localPeerConnection.createOffer();
                await localPeerConnection.setLocalDescription(offer);

                // POST tracks + offer
                const response = await fetch(`https://rtc.live.cloudflare.com/v1/apps/${APP_ID}/sessions/${sessionId}/tracks/new`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${APP_TOKEN}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        sessionDescription: { 
                            sdp: offer.sdp, 
                            type: offer.type 
                        },
                        tracks: transceivers.map(({ mid, sender }) => ({
                            location: 'local',
                            mid: mid,
                            trackName: sender.track?.id || 'anonymous'
                        }))
                    })
                });

                if (!response.ok) {
                    throw new Error(`Cloudflare API error: ${response.status}`);
                }

                const data = await response.json();
                
                if (!data.sessionDescription || !data.sessionDescription.type || !data.sessionDescription.sdp) {
                    throw new Error('Invalid response format from Cloudflare API');
                }

                // Set remote description with proper validation
                await localPeerConnection.setRemoteDescription(
                    new RTCSessionDescription({
                        type: data.sessionDescription.type,
                        sdp: data.sessionDescription.sdp
                    })
                );

                // Wait for ICE connection
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => reject(new Error("ICE connection timeout")), 10000);
                    
                    localPeerConnection.addEventListener("iceconnectionstatechange", () => {
                        if (localPeerConnection.iceConnectionState === "connected") {
                            clearTimeout(timeout);
                            resolve();
                        }
                    });
                });

            } catch (error) {
                console.error('Error setting up WebRTC:', error);
                throw error; // Re-throw to handle in initializeRoom
            }
        }

        function handleRemoteTrack(event) {
            const stream = event.streams[0];
            const participantId = stream.id;
            
            if (!participants.has(participantId)) {
                participants.set(participantId, {
                    stream: stream,
                    username: `Participant ${participants.size + 1}`
                });
                addVideoStream(participantId, participants.get(participantId).username, stream);
                updateParticipantsList();
            }
        }

        function addVideoStream(id, username, stream) {
            console.log('Adding video stream:', { id, username, streamId: stream.id });
            console.log('Stream tracks:', stream.getTracks().map(t => ({ kind: t.kind, id: t.id })));
            
            const videoWrapper = document.createElement('div');
            videoWrapper.className = 'video-wrapper';
            videoWrapper.id = `video-${id}`;

            const video = document.createElement('video');
            video.autoplay = true;
            video.playsInline = true;
            
            // Add error handling
            video.onerror = (e) => {
                console.error('Video error:', e);
            };
            
            // Add metadata and state handlers
            video.onloadedmetadata = () => {
                console.log(`Video metadata loaded for ${username}`);
                video.play().catch(e => console.error('Error playing video:', e));
            };

            video.onplay = () => {
                console.log(`Video playing for ${username}`);
            };

            video.onpause = () => {
                console.log(`Video paused for ${username}`);
            };

            // Set stream to video element
            try {
                video.srcObject = stream;
            } catch (e) {
                console.error('Error setting srcObject:', e);
                return;
            }

            if (id === 'local') {
                video.muted = true;
            }

            const nameTag = document.createElement('div');
            nameTag.className = 'participant-name';
            nameTag.textContent = username;

            videoWrapper.appendChild(video);
            videoWrapper.appendChild(nameTag);
            
            const videoGrid = document.getElementById('videoGrid');
            if (videoGrid) {
                videoGrid.appendChild(videoWrapper);
                console.log('Video element added to grid for:', username);
            } else {
                console.error('Video grid element not found');
            }
            
            updateGridLayout();
        }

        async function startSessionMonitoring() {
            setInterval(async () => {
                try {
                    const response = await fetch(`${API_BASE}/meetings/${roomId}/info`);
                    if (!response.ok) {
                        throw new Error('Failed to fetch meeting info');
                    }
                    const meetingInfo = await response.json();
                    
                    // Update participants based on meeting info
                    updateParticipants(meetingInfo);
                } catch (error) {
                    console.error('Error monitoring session:', error);
                }
            }, 5000);
        }

        async function updateParticipants(meetingInfo) {
            if (!meetingInfo || !meetingInfo.sessions) {
                console.warn('No valid meeting info provided');
                return;
            }

            console.log('Updating participants with:', meetingInfo.sessions);
            
            const participantsList = document.getElementById('participantsList');
            participantsList.innerHTML = '';
            
            const currentParticipants = new Set(participants.keys());
            
            for (const session of meetingInfo.sessions) {
                // Add to participants list UI
                const li = document.createElement('li');
                li.textContent = `${session.username}`;
                participantsList.appendChild(li);

                // Skip if this is the current user
                if (session.username === username) {
                    console.log('Skipping local user');
                    continue;
                }

                // Mark this participant as still active
                currentParticipants.delete(session.session_id);

                // Check if we need to add this participant's stream
                if (!participants.has(session.session_id)) {
                    console.log("New participant detected:", session);
                    
                    try {
                        // Get session state from Cloudflare
                        const sessionState = await fetch(
                            `https://rtc.live.cloudflare.com/v1/apps/${APP_ID}/sessions/${session.session_id}`, {
                            headers: {
                                "Authorization": `Bearer ${APP_TOKEN}`
                            }
                        }).then(res => res.json());

                        console.log('Session state received:', sessionState);

                        if (sessionState.tracks && sessionState.tracks.length > 0) {
                            const activeTracks = sessionState.tracks.filter(track => track.status === 'active');
                            console.log('Active tracks found:', activeTracks);
                            if (activeTracks.length > 0) {
                                await pullParticipantTracks(activeTracks, {
                                    session_id: session.session_id,
                                    username: session.username
                                });
                            }
                        }
                    } catch (err) {
                        console.error("Error getting participant session:", err);
                    }
                }
            }

            // Remove participants that are no longer in the session
            for (const oldParticipantId of currentParticipants) {
                console.log('Removing participant:', oldParticipantId);
                const videoElement = document.getElementById(`video-${oldParticipantId}`);
                if (videoElement) {
                    videoElement.remove();
                }
                participants.delete(oldParticipantId);
            }
            
            updateGridLayout();
            console.log('Final participants map:', Array.from(participants.entries()));
        }

        async function pullParticipantTracks(tracks, participant) {
            console.log('Pulling tracks for participant:', participant.username, tracks);
            try {
                const localSessionId = localPeerConnection.sessionId; 

                // Set up track reception promise
                const receivedTracksPromise = new Promise((resolve, reject) => {
                    const receivedTracks = new Map();
                    const timeout = setTimeout(() => {
                        console.warn('Track reception timeout');
                        reject(new Error("Track reception timeout"));
                    }, 10000);

                    function checkComplete() {
                        console.log('Checking track completion:', receivedTracks.size, 'of', tracks.length);
                        if (receivedTracks.size === tracks.length) {
                            clearTimeout(timeout);
                            resolve(Array.from(receivedTracks.values()));
                        }
                    }

                    const trackHandler = (event) => {
                        const track = event.track;
                        console.log("Received track:", track.kind, track.id);
                        receivedTracks.set(track.id, track);
                        checkComplete();

                        // Thêm stream handler
                        event.streams[0].onremovetrack = () => {
                            console.log('Track removed from stream:', track.id);
                        };
                    };

                    localPeerConnection.addEventListener('track', trackHandler);
                    setTimeout(() => localPeerConnection.removeEventListener('track', trackHandler), 10000);
                });

                // Pull remote tracks qua endpoint tracks/new
                const pullResponse = await fetch(
                    `https://rtc.live.cloudflare.com/v1/apps/${APP_ID}/sessions/${localSessionId}/tracks/new`,
                    {
                        method: "POST",
                        headers: {
                            "Authorization": `Bearer ${APP_TOKEN}`,
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({
                            tracks: tracks.map(track => ({
                                location: "remote",
                                sessionId: participant.session_id,
                                trackName: track.trackName
                            }))
                        })
                    }
                );

                if (!pullResponse.ok) {
                    throw new Error(`Failed to pull tracks: ${pullResponse.status}`);
                }

                const pullData = await pullResponse.json();
                console.log('Pull response:', pullData);

                // Handle renegotiation nếu cần
                if (pullData.requiresImmediateRenegotiation) {
                    console.log('Renegotiation required');
                    
                    await localPeerConnection.setRemoteDescription(
                        new RTCSessionDescription(pullData.sessionDescription)
                    );

                    const answer = await localPeerConnection.createAnswer();
                    await localPeerConnection.setLocalDescription(answer);

                    // Gửi answer lên Cloudflare
                    const renegotiateResponse = await fetch(
                        `https://rtc.live.cloudflare.com/v1/apps/${APP_ID}/sessions/${localSessionId}/renegotiate`,
                        {
                            method: "PUT",
                            headers: {
                                "Authorization": `Bearer ${APP_TOKEN}`,
                                "Content-Type": "application/json"
                            },
                            body: JSON.stringify({
                                sessionDescription: {
                                    sdp: answer.sdp,
                                    type: "answer"
                                }
                            })
                        }
                    );

                    if (!renegotiateResponse.ok) {
                        throw new Error(`Renegotiation failed: ${renegotiateResponse.status}`);
                    }

                    console.log('Renegotiation completed');
                }

                // Đợi tracks được nhận
                const receivedTracks = await receivedTracksPromise;
                
                if (receivedTracks.length === 0) {
                    throw new Error('No tracks received');
                }

                // Tạo MediaStream mới cho participant
                const remoteStream = new MediaStream();
                receivedTracks.forEach(track => {
                    console.log('Adding track to stream:', track.kind, track.id);
                    remoteStream.addTrack(track);
                });

                // Lưu thông tin participant
                participants.set(participant.session_id, {
                    stream: remoteStream,
                    username: participant.username
                });

                // Thêm video element
                addVideoStream(participant.session_id, participant.username, remoteStream);

            } catch (err) {
                console.error("Error pulling participant tracks:", err);
                console.error("Error details:", {
                    participant,
                    tracks,
                    error: err.message,
                    stack: err.stack
                });
            }
        }

        // Control handlers
        document.getElementById('toggleMicBtn').onclick = () => {
            const audioTrack = localStream.getAudioTracks()[0];
            audioTrack.enabled = !audioTrack.enabled;
            updateControls();
        };

        document.getElementById('toggleVideoBtn').onclick = () => {
            const videoTrack = localStream.getVideoTracks()[0];
            videoTrack.enabled = !videoTrack.enabled;
            updateControls();
        };

        document.getElementById('shareScreenBtn').onclick = async () => {
            try {
                const screenStream = await navigator.mediaDevices.getDisplayMedia();
                const videoTrack = screenStream.getVideoTracks()[0];
                
                const senders = localPeerConnection.getSenders();
                const videoSender = senders.find(sender => sender.track.kind === 'video');
                await videoSender.replaceTrack(videoTrack);
                
                videoTrack.onended = async () => {
                    const cameraTrack = localStream.getVideoTracks()[0];
                    await videoSender.replaceTrack(cameraTrack);
                    updateControls();
                };
                
                updateControls();
            } catch (error) {
                console.error('Error sharing screen:', error);
            }
        };

        document.getElementById('leaveBtn').onclick = async () => {
            try {
                // Close connections
                if (localPeerConnection) {
                    localPeerConnection.close();
                }
                
                // Stop all tracks
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                }
                
                // Notify backend
                await fetch(`${API_BASE}/meetings/${roomId}/leave`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username: username })
                });
                
                // Redirect to home
                window.location.href = 'index.html';
            } catch (error) {
                console.error('Error leaving meeting:', error);
            }
        };

        function updateControls() {
            const micBtn = document.getElementById('toggleMicBtn');
            const videoBtn = document.getElementById('toggleVideoBtn');
            
            const audioTrack = localStream.getAudioTracks()[0];
            const videoTrack = localStream.getVideoTracks()[0];
            
            micBtn.querySelector('.material-icons').textContent = audioTrack.enabled ? 'mic' : 'mic_off';
            videoBtn.querySelector('.material-icons').textContent = videoTrack.enabled ? 'videocam' : 'videocam_off';
            
            micBtn.classList.toggle('active', !audioTrack.enabled);
            videoBtn.classList.toggle('active', !videoTrack.enabled);
        }

        // Add this function to update grid layout based on participant count
        function updateGridLayout() {
            const grid = document.getElementById('videoGrid');
            const participantCount = grid.children.length;
            
            // Remove all existing layout classes
            grid.classList.remove(
                'single-participant',
                'two-participants',
                'few-participants',
                'many-participants'
            );

            // Add appropriate layout class based on participant count
            if (participantCount === 1) {
                grid.classList.add('single-participant');
            } else if (participantCount === 2) {
                grid.classList.add('two-participants');
            } else if (participantCount <= 4) {
                grid.classList.add('few-participants');
            } else {
                grid.classList.add('many-participants');
            }
        }

        // Initialize the room
        initializeRoom();
    </script>
</body>
</html>
